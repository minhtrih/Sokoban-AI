var json = {
    "listPoints": [
        {
            "row": 1, //person
            "point": {
                "x": 0,
                "y": 5,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 0
            }
        },
        {
            "row": 2,
            "point": {
                "x": 1,
                "y": 5,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 0
            }
        },
        {
            "row": 3,
            "point": {
                "x": 1,
                "y": 6,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 4,
            "point": {
                "x": 2,
                "y": 6,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 0
            }
        },
        {
            "row": 5,
            "point": {
                "x": 3,
                "y": 6,
                "t": 0,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 6,
            "point": {
                "x": 3,
                "y": 5,
                "t": 1,
                "l": 0,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 7,
            "point": {
                "x": 3,
                "y": 4,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 8,
            "point": {
                "x": 2,
                "y": 4,
                "t": 0,
                "l": 0,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 9,
            "point": {
                "x": 2,
                "y": 3,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 10,
            "point": {
                "x": 1,
                "y": 3,
                "t": 0,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 11,
            "point": {
                "x": 0,
                "y": 3,
                "t": 0,
                "l": 0,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 12,
            "point": {
                "x": 0,
                "y": 2,
                "t": 1,
                "l": 0,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 13,
            "point": {
                "x": 0,
                "y": 1,
                "t": 1,
                "l": 0,
                "r": 1,
                "b": 0
            }
        },
        {
            "row": 14,
            "point": {
                "x": 1,
                "y": 1,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 0
            }
        },
        {
            "row": 15,
            "point": {
                "x": 2,
                "y": 1,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 0
            }
        },
        {
            "row": 16,
            "point": {
                "x": 3,
                "y": 1,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 17,
            "point": {
                "x": 3,
                "y": 0,
                "t": 1,
                "l": 0,
                "r": 1,
                "b": 0
            }
        },
        {
            "row": 18,
            "point": {
                "x": 4,
                "y": 0,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 0
            }
        },
        {
            "row": 19,
            "point": {
                "x": 4,
                "y": 1,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 20,
            "point": {
                "x": 4,
                "y": 2,
                "t": 0,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 21,
            "point": {
                "x": 3,
                "y": 2,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 22,
            "point": {
                "x": 3,
                "y": 3,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 23,
            "point": {
                "x": 4,
                "y": 4,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 0
            }
        },
        {
            "row": 24,
            "point": {
                "x": 4,
                "y": 5,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 25,
            "point": {
                "x": 4,
                "y": 6,
                "t": 0,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 26, //box
            "point": {
                "x": 2,
                "y": 2,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 27,
            "point": {
                "x": 1,
                "y": 2,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 28,
            "point": {
                "x": 2,
                "y": 7,
                "t": 0,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 29,
            "point": {
                "x": 1,
                "y": 7,
                "t": 1,
                "l": 1,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 30,
            "point": {
                "x": 1,
                "y": 8,
                "t": 1,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 31,
            "point": {
                "x": 1,
                "y": 9,
                "t": 0,
                "l": 1,
                "r": 0,
                "b": 1
            }
        },
        {
            "row": 32, //goal
            "point": {
                "x": 0,
                "y": 9,
                "t": 0,
                "l": 0,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 33,
            "point": {
                "x": 0,
                "y": 8,
                "t": 1,
                "l": 0,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 34,
            "point": {
                "x": 0,
                "y": 7,
                "t": 1,
                "l": 0,
                "r": 1,
                "b": 1
            }
        },
        {
            "row": 35,
            "point": {
                "x": 0,
                "y": 6,
                "t": 1,
                "l": 0,
                "r": 1,
                "b": 1
            }
        }
    ]
};

/**
 * Hàm tọa độ x
 * @param x
 * @param y
 * @constructor
 */
function Coordinate(x, y) {
    this.x = x;
    this.y = y;
}

/**
 * Trạng thái vị trí box, player để xác định mỗi khi 2 obj này thay đổi tọa độ
 * @param box
 * @param player
 * @constructor
 */
function State(box, player) {
    this.box = box;
    this.player = player;
}


function Node(state, parent, cost, move) {
    this.state = state;
    this.parent = parent;
    this.cost = cost;
    this.move = move;
}

/**
 * Hàm so sánh 2 node
 * @param a
 * @param b
 * @returns {boolean}
 * @constructor
 */
function Compare(a, b) {
    if ((a.x == b.x) && (a.y == b.y)){
        return true;
    }
    return false;
}

/**
 * Kiểm tra tọa độ các walls
 * @param x
 * @param y
 * @returns {boolean}
 * @constructor
 */
function WallsContain(x, y) {
    for (var i in json.listPoints){
        if(x == json.listPoints[i].point.x && y == json.listPoints[i].point.y){
            return false;
        }
    }
    return true;
}

/**
 * Kiểm tra tọa độ x,y có trùng với tọa độ của goal ko
 * @param goal
 * @param x
 * @param y
 * @returns {boolean}
 * @constructor
 */
function GoalContain(goal, x, y) {
    if (goal[0] == x && goal[1] == y){
        return true;
    }
    return false;
}

/**
 * Tìm kiếm các walls bao quanh những tọa độ có trong json
 * @returns {Array}
 * @constructor
 */
function Walls() {
    var walls = [];
    for (var i in json.listPoints){
        var x = json.listPoints[i].point.x;
        var y = json.listPoints[i].point.y;
        if (!WallsContain(x, y)){
            var wall;
            if (WallsContain(x, y+1)){ //kiểm tra vị trí up của 1 điểm trong json xem có phải wall ko
                wall = new Coordinate(x, y+1);
                var flag = false;
                for (var j=0;j<walls.length;j++){
                    if(wall.x == walls[j].x && wall.y == walls[j].y){
                        flag = true;
                    }
                }
                if (flag == false){
                    walls.push(wall);
                }
            }
            if (WallsContain(x, y-1)){ //kiểm tra vị trí down của 1 điểm trong json xem có phải wall ko
                wall = new Coordinate(x, y-1);
                flag = false;
                for (var j=0;j<walls.length;j++){
                    if(wall.x == walls[j].x && wall.y == walls[j].y){
                        flag = true;
                    }
                }
                if (flag == false){
                    walls.push(wall);
                }
            }
            if (WallsContain(x+1, y)){ //kiểm tra vị trí right của 1 điểm trong json xem có phải wall ko
                wall = new Coordinate(x+1, y);
                flag = false;
                for (var j=0;j<walls.length;j++){
                    if(wall.x == walls[j].x && wall.y == walls[j].y){
                        flag = true;
                    }
                }
                if (flag == false){
                    walls.push(wall);
                }
            }
            if (WallsContain(x-1, y)){ //kiểm tra vị trí left của 1 điểm trong json xem có phải wall ko
                wall = new Coordinate(x-1, y);
                flag = false;
                for (var j=0;j<walls.length;j++){
                    if(wall.x == walls[j].x && wall.y == walls[j].y){
                        flag = true;
                    }
                }
                if (flag == false){
                    walls.push(wall);
                }
            }
        }
    }
    return walls;
}

/**
 * hàm ước lượng Heuristics
 * tham khảo hàm h() http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
 */
function Heuristics(goal) {
    this.goal = goal;
}

/**
 * Gets two Coordinate as variables, and adds the sum of differences of rows and columns
 * to get distance between two Coordinate
 * @param c1 coodinate 1
 * @param c2 coordinate 2
 * @return distance from c1 to c2
 */
Heuristics.prototype.Manhattan = function(c1, c2) {
    var d1 = Math.abs(c1.x - c2.x);
    var d2 = Math.abs(c1.y - c2.y);
    return d1 + d2;
}

/**
 * Calculates minimum distance from given object to each set of Coordinate
 * @param obj
 * @param sets
 * @param method
 * @return distance from obj to closest coordinate in the hashset
 */

Heuristics.prototype.GetDish = function(object, set) {
    var minDist = 1000000;
    //For each coordinate in a set, calculate the distance according to given heuristic choice
    var dist = this.Manhattan(object, set);
    if (dist < minDist){
        minDist = dist;
    }
    return minDist;
}

/**
 * Receives state and heuristic choice as parameters and calculates the distance for each box and player
 * @param s state
 * @param str heuristics choice
 * @return sum of distances for player and boxes
 */

Heuristics.prototype.Caculate = function(state) {
    var sum =0;
    var player = state.player;
    sum += this.GetDish(player, box);
    sum += this.GetDish(box, goal);
    return sum;
}


/**
 * Hàm problem để xử lý các vấn đề, trường hợp xảy ra trong bài toán sokoban
 */
function Problem(walls, initialState, goal) {
    this.initialState = initialState;
    this.walls = walls;
    this.goal = goal;
}


/**
 * Kiểm trả vị trí của box đã trùng với goal chưa
 * @param state
 * @returns {boolean}
 * @constructor
 */
Problem.prototype.GoalTest = function(state) {
    if (Compare(state.box, goal)){
        return true;
    }
    return false;
}


/**
 * Kiểm trả vị trí deadlock trong map để tránh không cho các box đi vào
 * @param state
 * @returns {boolean}
 * @constructor
 */
Problem.prototype.DeadLockTest = function(state) {
    var x = state.box.x;
    var y = state.box.y;
    if(!GoalContain(goal, x, y)){
        if (WallsContain(x+1, y)&&WallsContain(x, y-1))
            return true; //top & left
        if (WallsContain(x+1, y)&&WallsContain(x, y+1))
            return true; //top & right
        if (WallsContain(x-1, y)&&WallsContain(x, y-1))
            return true; //bottom & left
        if (WallsContain(x-1, y)&&WallsContain(x, y+1))
            return true; //bottom & right

        if (WallsContain(x+1, y-1)&&WallsContain(x+1, y)&&
            WallsContain(x+1, y+1)&&WallsContain(x, y-2)&&
            WallsContain(x, y+2)&&(!GoalContain(goal, x, y-1))&&
            !GoalContain(goal, x, y+1))
            return true; //top & sides
        if (WallsContain(x-1, y-1)&&WallsContain(x-1, y)&&
            WallsContain(x-1, y+1)&&WallsContain(x, y-2)&&
            WallsContain(x, y+2)&&(!GoalContain(goal, x, y-1))&&
            (!GoalContain(goal, x, y+1)))
            return true; //bottom & sides
        if (WallsContain(x+1, y-1)&&WallsContain(x, y-1)&&
            WallsContain(x-1, y-1)&&WallsContain(x+2, y)&&
            WallsContain(x-2, y)&&(!GoalContain(goal, x+1, y))&&
            (!GoalContain(goal, x-1, y)))
            return true; //left & vertical
        if (WallsContain(x+1, y+1)&&WallsContain(x, y+1)&&
            WallsContain(x-1, y+1)&&WallsContain(x+2, y)&&
            WallsContain(x-2, y)&&(!GoalContain(goal, x+1, y))&&
            (!GoalContain(goal, x-1, y)))
            return true; //right & top/bottom
    }
    return false
}

/**
 * Kiểm tra những vị trí đi được trong của player khi đang ở vị trí hiện tại
 * @param state
 * @return arraylist of strings (u d l r)
 */
Problem.prototype.Action = function(state) {
    var x = state.player.x;
    var y = state.player.y;
    var arraylist = [];
    var newplayer = new Coordinate(x, y+1);
    var newbox = new Coordinate(x, y+2);
    if (!WallsContain(newplayer.x, newplayer.y)){
        if (Compare(newplayer, box) && (Compare(newbox, box) || (WallsContain(newbox.x, newbox.y)))){
        } else {
            // console.log("u");
            arraylist.push("u");
        }
    }

    newplayer = new Coordinate(x+1, y);
    newbox = new Coordinate(x+2,y);
    if (!WallsContain(newplayer.x, newplayer.y)){
        if (Compare(newplayer, box) && (Compare(newbox, box) || (WallsContain(newbox.x, newbox.y)))){
        } else {
            // console.log("r");
            arraylist.push("r");
        }
    }

    newplayer = new Coordinate(x, y-1);
    newbox = new Coordinate(x, y-2);
    if (!WallsContain(newplayer.x, newplayer.y)){
        if (Compare(newplayer, box) && (Compare(newbox, box) || (WallsContain(newbox.x, newbox.y)))){
        } else {
            // console.log("d");
            arraylist.push("d");
        }
    }

    newplayer = new Coordinate(x-1, y);
    newbox = new Coordinate(x-2, y);
    if (!WallsContain(newplayer.x, newplayer.y)){
        if (Compare(newplayer, box) && (Compare(newbox, box) || (WallsContain(newbox.x, newbox.y)))){
        } else {
            // console.log("l");
            arraylist.push("l");
        }
    }
    // console.log("|||");
    return arraylist;
}


/**
 * Phần này để tính toán giải pháp và ra quyết định bước đi đẩy box của bài toán
 * @param h
 * @constructor
 */
function Search(h) {
    Search.h = h;
}

/**
 * Để in ra kết quả, đáp an của bài toán
 * @return {string}
 *
 */
Search.prototype.GetSolution = function(n, totalTime) {
    var result = "";
    var steps = 0;
    if (n == null){
        result = "Bó tay, bạn tự giải đi";
    } else {
        while (n.parent != null){
            result = n.move + result;
            n = n.parent;
            steps++;
        }
    }
    result = result + "\n(total of " + steps + " steps)" + "\nRun time of the algorithm: " + totalTime +"ms";
    return result;
}

/**
 * Phương thức GetChild trả về nút con theo hành động được thực hiện (l, r, u, d)
 * Thêm 1 vào newCost bất cứ khi nào hộp được đẩy
 * @param n
 * @param action
 * @returns {Node}
 * @constructor
 */
Search.prototype.GetChild = function(n, action) {
    var box = n.state.box;
    var x = n.state.player.x;
    var y = n.state.player.y;
    var newCost = n.cost+1;
    var newPlayer = new Coordinate(n.state.player.x, n.state.player.y);
    // console.log(newPlayer);
    var choice = action[0];
    switch (choice) {
        case 'u':
            //update player coordinate
            newPlayer = new Coordinate(x, y+1);
            //check if player is pushing a box
            if (Compare(newPlayer, box)){
                //update box coordinate
                box = new Coordinate(x, y+2);
                newCost++;
            }
            break;
        case 'd':
            //update player coordinate
            newPlayer = new Coordinate(x, y-1);
            //check if player is pushing a box
            if (Compare(newPlayer, box)){
                //update box coordinate
                box = new Coordinate(x, y-2);
                newCost++;
            }
            break;
        case 'l':
            //update player coordinate
            newPlayer = new Coordinate(x-1, y);
            //check if player is pushing a box
            if (Compare(newPlayer, box)){
                //update box coordinate
                box = new Coordinate(x-2, y);
                newCost++;
            }
            break;
        case 'r':
            //update player coordinate
            newPlayer = new Coordinate(x+1, y);
            //check if player is pushing a box
            if (Compare(newPlayer, box)){
                //update box coordinate
                box = new Coordinate(x+2, y);
                newCost++;
            }
            break;

    }
    // console.log(new State(box, newPlayer));
    return new Node(new State(box, newPlayer), n, newCost, choice.toString());
}

/**
 * kiểm tra state
 * @param set1
 * @param set2
 * @returns {boolean}
 * @constructor
 */
Search.prototype.Contains = function(set1, set2) {
    for (var i in set1){
        if(Compare(set1[i].box, set2.box) && (Compare(set1[i].player, set2.player))){
            return true;
        }
    }
    return false;
}

/**
 * kiểm trả node
 * @param node1
 * @param node2
 * @returns {boolean}
 * @constructor
 */
Search.prototype.ContainsNode = function (node1, node2) {
    for (var i in node1){
        if(Compare(node1[i].state.box, node2.state.box) && (Compare(node1[i].state.player, node2.state.player)))
            return true;
    }
    return false;
}

/**
 * So sánh f() để sắp xếp
 * @return {number}
 */
Search.prototype.Comparator = function(n1, n2) {
    var f1 = n1.cost + h.Caculate(n1.state); //f = g() + h()
    var f2 = n2.cost + h.Caculate(n2.state);
    return f1-f2;
}

/**
 * Tính toán, so sánh để ra những bước đi đẩy thùng nhanh nhất
 * @param p
 * @returns {string}
 * @constructor
 */
Search.prototype.PrioritySearch = function (p){
    var currentTime = new Date();
    currentTime = currentTime.getTime();
    var initial = new Node(state, null, 0, '');
    var explored = [];
    var fringe = [];
    fringe.push(initial);
    fringe.sort(this.Comparator);
    while (fringe.length != 0){
        var n = fringe.shift();
        if (p.GoalTest(n.state)){
            return this.GetSolution(n, new Date().getTime() - currentTime);
        }
        if (!p.DeadLockTest(n.state)){
            explored.push(n.state);

            var actions = p.Action(n.state);
            for (var i=0; i<actions.length; i++){
                var child = this.GetChild(n, actions[i]);
                if ((child != null) && (child.state != null)){
                    if (!(this.Contains(explored, child.state) &&(!this.ContainsNode(fringe, child)))){
                        fringe.push(child);
                        fringe.sort(this.Comparator);
                    }
                    else {
                        for (var next in fringe){
                            //Kiểm tra xem fringe có chưa trạng thái trên và so sánh cost
                            if (next == child){
                                if (child.cost < next.cost){
                                    next = child;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return this.GetSolution(n, new Date().getTime() - currentTime);
}


var box = new Coordinate(2,2);
var goal = new Coordinate(0,9);
var player = new Coordinate(0,5);
var state = new State(box, player);
var walls = Walls();
var h = new Heuristics(goal);

/**
 * Khởi tạo
 * @returns {string}
 * @constructor
 */
function Solve() {
    var s = new Search(Heuristics(goal));
    return s.PrioritySearch(new Problem(walls, new State(box, player), goal));
}

console.log(Solve());